---
layout: single
title: "React 렌더링 최적화"
published: true
classes: wide
category: React Query
---

# React 렌더링 최적화 (React.memo, useMemo, useCallback)

**한 눈에 보는 결론**
* useMemo는 **결과 값**을 캐싱한다.
* useCallback은 **함수**를 캐싱한다.
* React.memo는 **고차 컴포넌트**로, 컴포넌트의 리렌더링을 최소화한다.

## 성능 최적화 필수성
React로 개발할 때, 누구나 한 번씩 고민하게 되는 주제. 그것은 바로 **성능 최적화**다.
###### 사용자 경험을 향상시키고, 불필요한 렌더링을 줄여 앱의 효율을 높이는 것.

## 성능 저하의 주요 원인
성능 저하를 일으키는 원인은 다양하지만 그 중 주요 원인을 알아보자.
1. **불필요한 렌더링**. state가 변경될 때, 변화가 없는 컴포넌트까지 불필요하게 렌더링 되는 것.
2. **복잡한 계산식**. 복잡한 계산과 데이터 처리는 앱의 자원을 많이 소모하여, 사용자 경험을 저해하는 것. (ex. 입력 폼)

이 외에도 다양한 원인이 있지만, 주제를 벗어나지 않도록 마무리 짓고, 주요 원인을 해결할 수 있는 방법을 설명해보겠다.

# useMemo
# useCallback
# React.memo

React의 고차 컴포넌트이다.

컴포넌트가 리렌더링될 때, 해당 컴포넌트의 ```props```나 ```state```가 변경되면 React는 기본적으로 컴포넌트를 리렌더링한다.
이러한 이유 때문에 부모 컴포넌트가 리렌더링할 때, 리렌더링이 필요없는 자식 컴포넌트도 함께 리렌더링되며 자원 낭비를 하는 경우가 생긴다.

이럴 때, React.memo를 사용하면 불필요한 렌더링을 방지할 수 있다.

```React.memo```로 래핑된 컴포넌트는 이전에 렌더링된 결과를 기억하고, 이전 ```props```와 현재 ```props```를 비교하여 변경 여부를 판단한다.
만약 ```props```가 동일하다면 이전에 렌더링된 결과를 재사용하여 불필요한 리렌더링을 방지한다. 


